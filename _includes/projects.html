<hr class="projects-hr" />
<div class="cytosplore" id="projects">
  <div class="content-wrapper">
    <div class="section">
      <p>
Cytosplore Viewer is a stand-alone application built on top of ManiVault Studio [citation], a plugin-based high-performance application building environment for Windows, MacOS and Linux. It enables agile, low-effort construction of specialized data viewers for integrated exploration across datasets. Departing from a single application installer, different BICAN data viewers can be ingested as system state files that are self-contained, including compressed data and GUI configurations. In addition, multiple mechanisms are available to ingest slices of data and taxonomy versions from the ABC-atlas portal, either through a python bridge, through ingestion of standardized taxonomy file formats or URL transfer of ABC atlas cell selections into Cytosplore. 

Cytosplore Viewer provides a complementary data analysis and visualization to the HMBA data visualization web portal, focusing on fast local compute for the linked exploration of multi-modal spatial and single cell datasets. It offers on high interactivity, low-latency  and on-the-fly analyses, complementing the BKP functionality with interactive, visual analytics across multiple datasets, providing for instance : 

        <ul>
          <li>
            <b>Deepdives in single-cell and spatial data </b> for in-depth re-analysis of subsets of cells, either dispatched from the HMBA data portal, or directly in Cytosplore Viewer. Specific niche functionalities are on-the-fly re-embedding, local gene expression gradients detection, differential expression analysis and manual annotation / correction facilities.
          </li>
          <li>
            <b>Comparative visualization </b> visualization for direct comparative analyses of single cell and spatial data across multiple species and / or between brain regions. Central in these comparisons is the identification of conserved and diverging features patterns across these datasets and relate these to evolutionary and anatomical prior knowledge. 
          </li>
          <li>
            <b>Multimodal single-cell feature integration</b> for linked visualization of for instance patch-seq data (for exploration of annotated t-typed cells in relation to their morphological and electrophysiological features) and ATAC-seq / spatial / RNA-seq combinations.
          </li>
        </ul>
      </p>
      <br />
      <div class="projects-grid" id="projects-container"></div>
    </div>
  </div>
</div>

<head>
  <link
    rel="stylesheet"
    href="/assets/css/fontawesome-all.css"
    type="text/css"
  />
  <link rel="stylesheet" href="/assets/css/style-viewer.css" type="text/css" />
  <link
    rel="stylesheet"
    href="/assets/css/style-projects.css"
    type="text/css"
  />
</head>

<script>
  const PROJECT_GROUPS = [
    {
      key: "HMBA",
      path: "/assets/projects/HMBA",
      title: "Human Mammalian Brain Atlas",
      description:
        "HMBA projects focus on large-scale mapping and interactive exploration of mammalian brain single-cell datasets.",
    },
    {
      key: "SimianEvo",
      path: "/assets/projects/SimianEvo",
      title: "Cross-Species Analysis in Single-Cell Transcriptomics",
      description:
        "EvoViewer and Simian projects provide comparative and evolutionary visualizations across species.",
    },
    {
      key: "Cortical",
      path: "/assets/projects/Cortical",
      title: "Studies of the Mammalian Cortex",
      description:
        "Cortex projects focus on cortical surface mapping, annotations, and region-based analyses.",
    },
  ];

  document.addEventListener("DOMContentLoaded", () => {
    loadAllGroups();
  });

  async function loadAllGroups() {
    const container = document.getElementById("projects-container");
    container.innerHTML = "";

    // Create placeholders for all groups first so DOM is ready
    for (const group of PROJECT_GROUPS) {
      const groupEl = document.createElement("section");
      groupEl.className = "project-group";
      groupEl.innerHTML = `<h2 class="group-title">${
        group.title
      }</h2><p class="group-desc">${
        group.description || ""
      }</p><div class="group-list" id="group-${
        group.key
      }"><p class="loading">Loading...</p></div>`;
      container.appendChild(groupEl);
    }

    const loadPromises = PROJECT_GROUPS.map((group) =>
      loadGroupMarkdowns(group.path, `group-${group.key}`).catch((e) => {
        console.error(e);
        const target = document.getElementById(`group-${group.key}`);
        if (target)
          target.innerHTML = `<p class="error">Failed to load projects for ${group.title}</p>`;
      })
    );

    await Promise.all(loadPromises);
  }

  async function loadGroupMarkdowns(folderPath, targetId) {
    const target = document.getElementById(targetId);
    if (!target) return;
    target.innerHTML = "";
    let files = await listMdFiles(folderPath);

    if (!files || files.length === 0) {
      target.innerHTML = "<p>No projects found in this group.</p>";
      return;
    }

    files = Array.from(new Set(files)).sort((a, b) => compareVersions(b, a));

    const cards = [];
    for (const f of files) {
      try {
        const r = await fetch(`${folderPath}/${f}`);
        if (!r.ok) continue;
        const md = await r.text();
        const parsed = parseProjectMarkdown(md, f);
        cards.push(parsed);
      } catch (e) {
        console.warn("Could not load", f, e);
      }
    }

    if (cards.length === 0) {
      target.innerHTML = "<p>No project markdowns could be loaded.</p>";
      return;
    }

    const grid = document.createElement("div");
    grid.className = "projects-cards";
    for (let idx = 0; idx < cards.length; idx++) {
      grid.appendChild(renderCard(cards[idx], idx));
    }
    target.appendChild(grid);
  }

  function parseProjectMarkdown(md, fname) {
    const lines = md.split(/\r?\n/);
    const data = {
      title: "",
      image: "",
      description: "",
      authors: "",
      year: "",
      venue: "",
      links: [],
      fname,
    };
    const desc = [];

    for (let i = 0; i < lines.length; i++) {
      const raw = lines[i];
      const line = raw.trim();
      if (!data.title && line.startsWith("# ")) {
        data.title = line.replace(/^# /, "").trim();
        continue;
      }
      const img = line.match(/!\[(.*?)\]\((.*?)\)/);
      if (!data.image && img) {
        data.image = img[2];
        continue;
      }
      if (line.startsWith("**Authors:**")) {
        data.authors = line.replace("**Authors:**", "").trim();
        continue;
      }
      if (line.startsWith("**Year:**")) {
        data.year = line.replace("**Year:**", "").trim();
        continue;
      }
      if (line.startsWith("**Venue:**")) {
        data.venue = line.replace("**Venue:**", "").trim();
        continue;
      }
      const link = line.match(/- \[(.*?)\]\((.*?)\)/);
      if (link) {
        data.links.push({ text: link[1], url: link[2] });
        continue;
      }
      if (line !== "" && !line.startsWith("**")) desc.push(raw);
    }

    data.description = desc.join("\n").trim();
    return data;
  }

  async function listMdFiles(folderPath) {
    const files = [];
    try {
      const resp = await fetch(folderPath + "/");
      if (resp.ok) {
        const text = await resp.text();
        // Find hrefs to .md files
        const regex = /href=\"([^\"]+\.md)\"/gi;
        let m;
        while ((m = regex.exec(text)) !== null) {
          const name = m[1].replace(/^\.\//, "");
          files.push(name);
        }
      }
    } catch (e) {
      // ignore
    }

    if (files.length > 0) return files;

    const candidates = [];
    for (let major = 5; major >= 0; major--) {
      for (let minor = 10; minor >= 0; minor--) {
        candidates.push(`v${major}.${minor}.md`);
        for (let patch = 3; patch >= 0; patch--)
          candidates.push(`v${major}.${minor}.${patch}.md`);
      }
      for (let i = 10; i >= 1; i--) candidates.push(`${i}.md`);
    }

    const concurrency = 6;
    const found = [];
    for (let i = 0; i < candidates.length; i += concurrency) {
      const batchNames = candidates.slice(i, i + concurrency);
      const batch = batchNames.map((name) =>
        fetch(`${folderPath}/${name}`)
          .then((r) => (r.ok ? name : null))
          .catch(() => null)
      );
      const res = await Promise.all(batch);
      for (const s of res) if (s) found.push(s);
      if (found.length > 20) break;
    }

    return found;
  }
  function compareVersions(a, b) {
    const pa = parseVersion(a);
    const pb = parseVersion(b);
    for (let i = 0; i < 4; i++) {
      const na = pa[i] || 0;
      const nb = pb[i] || 0;
      if (na !== nb) return na - nb;
    }
    return 0;
  }

  function parseVersion(name) {
    const base = name.replace(/\.md$/i, "").replace(/^v/i, "");
    const parts = base
      .split(/[\.\-_]/)
      .map((p) => parseInt(p, 10))
      .filter((n) => !isNaN(n));
    while (parts.length < 4) parts.push(0);
    return parts.slice(0, 4);
  }

  function renderCard(data, index) {
    const article = document.createElement("div");
    article.className = "paper";

    const align = index % 2 === 0 ? "left" : "right";
    const imgHtml = data.image
      ? `<div class="paper-image ${align}"><img src="${
          data.image
        }" alt="${escapeHtml(data.title)}" class="paper-img"/></div>`
      : "";

    let meta = "";
    if (data.authors || data.year || data.venue) {
      meta += '<p class="paper-metadata">';
      if (data.authors)
        meta += `<i class="fas fa-user"></i> ${escapeHtml(data.authors)}`;
      if (data.year)
        meta += ` | <i class="fas fa-calendar-alt"></i> ${escapeHtml(
          data.year
        )}`;
      if (data.venue)
        meta += ` | <i class="fas fa-map-marker-alt"></i> ${escapeHtml(
          data.venue
        )}`;
      meta += "</p>";
    }

    let links = "";
    if (data.links && data.links.length) {
      links =
        '<p class="paper-metadata">' +
        data.links
          .map((l) => {
            const icon = getIconClass(l.text);
            const isSame =
              l.text.toLowerCase().includes("tutorial") ||
              l.text.toLowerCase().includes("viewer");
            const targ = isSame ? "_self" : "_blank";
            const rel = isSame ? "" : ' rel="noopener noreferrer"';
            return ` <a href="${
              l.url
            }" target="${targ}"${rel}><i class="${icon}"></i> ${escapeHtml(
              l.text
            )}</a>`;
          })
          .join(" | ") +
        "</p>";
    }

    article.innerHTML = `
      <div class="paper-content-wrapper">
        ${imgHtml}
        <h3>${escapeHtml(data.title)}</h3>
        ${meta}
        <div class="paper-abstract"><p>${escapeHtml(
          truncateText(data.description, 350)
        )}</p></div>
        ${links}
      </div>
    `;

    return article;
  }

  function truncateText(t, n) {
    if (!t) return "";
    return t.length > n ? t.substring(0, n) + "..." : t;
  }
  function escapeHtml(s) {
    if (!s) return "";
    return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }

  function getIconClass(linkText) {
    const text = (linkText || "").toLowerCase();
    if (text.includes("video")) return "fas fa-video";
    if (text.includes("github")) return "fab fa-github";
    if (text.includes("pdf")) return "fas fa-file-pdf";
    if (text.includes("slides")) return "fas fa-file-powerpoint";
    if (text.includes("code")) return "fas fa-code";
    if (
      text.includes("paper") ||
      text.includes("preprint") ||
      text.includes("publication")
    )
      return "fas fa-file-alt";
    if (text.includes("website")) return "fas fa-globe";
    if (text.includes("article")) return "fas fa-newspaper";
    if (text.includes("tutorial")) return "fas fa-chalkboard-teacher";
    if (text.includes("classic viewer") || text.includes("combined viewer"))
      return "fas fa-download";
    return "fas fa-link";
  }
</script>
